Index: src/test/java/ru/ssau/tk/pmi/functions/functions/ConstantFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/ConstantFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/ConstantFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254096)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/ConstantFunctionTest.java	(date 1759256254096)
@@ -0,0 +1,91 @@
+package ru.ssau.tk.pmi.functions.functions;
+
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.ConstantFunction;
+import ru.ssau.tk.pmi.functions.UnitFunction;
+import ru.ssau.tk.pmi.functions.ZeroFunction;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+public class ConstantFunctionTest {
+
+    @Test
+    public void testConstantFunctionWithDifferentValues() {
+        ConstantFunction func1 = new ConstantFunction(5.5);
+        ConstantFunction func2 = new ConstantFunction(-3.2);
+        ConstantFunction func3 = new ConstantFunction(0.0);
+
+        assertEquals(5.5, func1.apply(10.0), 0.0001);
+        assertEquals(5.5, func1.apply(-5.0), 0.0001);
+
+        assertEquals(-3.2, func2.apply(100.0), 0.0001);
+        assertEquals(-3.2, func2.apply(0.0), 0.0001);
+
+        assertEquals(0.0, func3.apply(7.0), 0.0001);
+        assertEquals(0.0, func3.apply(-2.0), 0.0001);
+    }
+
+    @Test
+    public void testConstantFunctionGetConstant() {
+        ConstantFunction function = new ConstantFunction(3.14);
+        assertEquals(3.14, function.getConstant(), 0.0001);
+    }
+
+    @Test
+    public void testZeroFunctionAlwaysReturnsZero() {
+        ZeroFunction zero = new ZeroFunction();
+
+        assertEquals(0.0, zero.apply(0.0), 0.0001);
+        assertEquals(0.0, zero.apply(10.0), 0.0001);
+        assertEquals(0.0, zero.apply(-5.0), 0.0001);
+        assertEquals(0.0, zero.apply(100.0), 0.0001);
+    }
+
+    @Test
+    public void testUnitFunctionAlwaysReturnsOne() {
+        UnitFunction unit = new UnitFunction();
+
+        assertEquals(1.0, unit.apply(0.0), 0.0001);
+        assertEquals(1.0, unit.apply(7.0), 0.0001);
+        assertEquals(1.0, unit.apply(-2.0), 0.0001);
+        assertEquals(1.0, unit.apply(50.0), 0.0001);
+    }
+
+    @Test
+    public void testZeroFunctionGetConstant() {
+        ZeroFunction zero = new ZeroFunction();
+        assertEquals(0.0, zero.getConstant(), 0.0001);
+    }
+
+    @Test
+    public void testUnitFunctionGetConstant() {
+        UnitFunction unit = new UnitFunction();
+        assertEquals(1.0, unit.getConstant(), 0.0001);
+    }
+
+    @Test
+    public void testMultipleCallsConsistency() {
+        ConstantFunction constFunc = new ConstantFunction(42.0);
+        ZeroFunction zeroFunc = new ZeroFunction();
+        UnitFunction unitFunc = new UnitFunction();
+        // Проверяем, что многократные вызовы с разными аргументами
+        // возвращают одно и то же значение
+        for (int i = 0; i < 5; i++) {
+            double testValue = i * 10 - 20; // Разные тестовые значения
+            assertEquals(42.0, constFunc.apply(testValue), 0.0001);
+            assertEquals(0.0, zeroFunc.apply(testValue), 0.0001);
+            assertEquals(1.0, unitFunc.apply(testValue), 0.0001);
+        }
+    }
+
+    @Test
+    public void testNoNewFieldsInSubclasses() {
+        ZeroFunction zero = new ZeroFunction();
+        UnitFunction unit = new UnitFunction();
+
+        // Проверяем, что геттер возвращает ожидаемые значения
+        // без дополнительных полей в подклассах
+        assertEquals(0.0, zero.getConstant(), 0.0001);
+        assertEquals(1.0, unit.getConstant(), 0.0001);
+    }
+}
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/CompositeFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/CompositeFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/CompositeFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254059)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/CompositeFunctionTest.java	(date 1759256254059)
@@ -0,0 +1,255 @@
+package ru.ssau.tk.pmi.functions.functions;
+
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.*;
+
+import static org.junit.jupiter.api.Assertions.*;
+public class CompositeFunctionTest {
+    static class PlusOneFunction implements MathFunction {
+        public double apply(double x) {
+            return x + 1;
+        }
+    }
+    static class TimesTwoFunction implements MathFunction {
+        public double apply(double x) {
+            return x * 2;
+        }
+    }
+    static class MinusFiveFunction implements MathFunction {
+        public double apply(double x) {
+            return x - 5;
+        }
+    }
+    static class TimesThreeFunction implements MathFunction {
+        public double apply(double x) {
+            return x * 3;
+        }
+    }
+    static class PlusTwoFunction implements MathFunction {
+        public double apply(double x) {
+            return x + 2;
+        }
+    }
+    static class DivideByTwoFunction implements MathFunction {
+        public double apply(double x) {
+            return x / 2;
+        }
+    }
+    static class MinusThreeFunction implements MathFunction {
+        public double apply(double x) {
+            return x - 3;
+        }
+    }
+    static class CosFunction implements MathFunction {
+        public double apply(double x) {
+            return Math.cos(x);
+        }
+    }
+    @Test
+    public void testSimpleAndThen() {
+        MathFunction f = new SqrFunction();
+        MathFunction g = new IdentityFunction();
+
+        MathFunction composite = f.andThen(g);
+        assertEquals(25.0, composite.apply(5.0), 0.0001);
+        assertEquals(9.0, composite.apply(3.0), 0.0001);
+    }
+    @Test
+    public void testDoubleComposition() {
+        MathFunction f = new SqrFunction();
+        MathFunction g = new PlusOneFunction();
+        MathFunction h = new TimesTwoFunction();
+        MathFunction composite = f.andThen(g).andThen(h);
+        assertEquals(52.0, composite.apply(5.0), 0.0001);
+        assertEquals(20.0, composite.apply(3.0), 0.0001);
+    }
+    @Test
+    public void testTripleComposition() {
+        MathFunction f = new SqrFunction();
+        MathFunction g = new PlusOneFunction();
+        MathFunction h = new TimesTwoFunction();
+        MathFunction i = new MinusFiveFunction();
+
+        MathFunction composite = f.andThen(g).andThen(h).andThen(i);
+        assertEquals(47.0, composite.apply(5.0), 0.0001);
+        assertEquals(15.0, composite.apply(3.0), 0.0001);
+    }
+    @Test
+    public void testWithConstantFunction() {
+        MathFunction constant = new ConstantFunction(5.0);
+        MathFunction sqr = new SqrFunction();
+        MathFunction composite = constant.andThen(sqr);
+        assertEquals(25.0, composite.apply(10.0), 0.0001);
+        assertEquals(25.0, composite.apply(-5.0), 0.0001);
+    }
+    @Test
+    public void testWithZeroFunction() {
+        MathFunction zero = new ZeroFunction();
+        MathFunction sqr = new SqrFunction();
+        MathFunction composite = zero.andThen(sqr);
+        assertEquals(0.0, composite.apply(100.0), 0.0001);
+        assertEquals(0.0, composite.apply(-50.0), 0.0001);
+    }
+    @Test
+    public void testChainWithDifferentFunctions() {
+        MathFunction f = new TimesThreeFunction();
+        MathFunction g = new PlusTwoFunction();
+        MathFunction h = new DivideByTwoFunction();
+        MathFunction composite = f.andThen(g).andThen(h);
+        assertEquals(8.5, composite.apply(5.0), 0.0001);
+        assertEquals(4.0, composite.apply(2.0), 0.0001);
+    }
+    @Test
+    public void testCompositeFunctionStructure() {
+        MathFunction f = new SqrFunction();
+        MathFunction g = new IdentityFunction();
+        CompositeFunction composite = f.andThen(g);
+        assertInstanceOf(CompositeFunction.class, composite);
+        assertEquals(f, composite.getFirstFunction());
+        assertEquals(g, composite.getSecondFunction());
+    }
+    @Test
+    public void testMultipleAndThenCalls() {
+        MathFunction f = new PlusOneFunction();
+        MathFunction g = new TimesTwoFunction();
+        MathFunction h = new MinusThreeFunction();
+        MathFunction composite1 = f.andThen(g).andThen(h);
+        assertEquals(9.0, composite1.apply(5.0), 0.0001);
+    }
+    @Test
+    public void testComplexMathematicalChain() {
+        MathFunction sqr = new SqrFunction();
+        MathFunction plusOne = new PlusOneFunction();
+        MathFunction cos = new CosFunction();
+        MathFunction composite = sqr.andThen(plusOne).andThen(cos);
+        double result = composite.apply(0.0);
+        assertEquals(Math.cos(1.0), result, 0.0001);
+    }
+
+    @Test
+    public void testWithBSpline() {
+        double[] nodes = {0.0, 0.0, 1.0, 2.0, 2.0};
+        double[] weights = {1.0, 2.0, 3.0};
+        MathFunction spline = new BSplineFunction(nodes, 1, weights);
+        MathFunction square = new SqrFunction();
+
+        CompositeFunction composite = new CompositeFunction(square, spline);
+
+        double result = composite.apply(1.0);
+        assertTrue(result >= 0.0);
+    }
+
+    @Test
+    public void testComplexNestedComposition() {
+
+        MathFunction addOne = x -> x + 1;
+        MathFunction multiplyTwo = x -> x * 2;
+
+        MathFunction square = new SqrFunction();
+
+        CompositeFunction inner = new CompositeFunction(addOne, multiplyTwo);
+        CompositeFunction outer = new CompositeFunction(inner, square);
+
+        assertEquals(4.0, outer.apply(0.0), 1e-9);
+        assertEquals(16.0, outer.apply(1.0), 1e-9);
+        assertEquals(36.0, outer.apply(2.0), 1e-9);
+    }
+
+    @Test
+    public void testMultipleComposition() {
+        MathFunction addOne = x -> x + 1;
+        MathFunction multiplyTwo = x -> x * 2;
+        MathFunction subtractThree = x -> x - 3;
+
+        CompositeFunction firstComposite = new CompositeFunction(addOne, multiplyTwo);
+        CompositeFunction finalComposite = new CompositeFunction(firstComposite, subtractThree);
+
+        assertEquals(-1.0, finalComposite.apply(0.0), 1e-9);  // ((0+1)*2)-3 = -1
+        assertEquals(1.0, finalComposite.apply(1.0), 1e-9);   // ((1+1)*2)-3 = 1
+        assertEquals(5.0, finalComposite.apply(2.0), 1e-9);   // ((2+1)*2)-3 = 3
+    }
+    @Test
+    public  void testTwoArrayTabledFunctions(){
+        double[] xValues1 = {1,2,3};
+        double[] yValues1 = {10,20,30};
+        double[] xValues2 = {10,20,30};
+        double[] yValues2 = {100,200,300};
+        ArrayTabulatedFunction func1 =  new ArrayTabulatedFunction(xValues1,yValues1);
+        ArrayTabulatedFunction func2 =  new ArrayTabulatedFunction(xValues2,yValues2);
+        CompositeFunction func = new CompositeFunction(func1,func2);
+        assertEquals(100, func.apply(1), 0.001);
+    }
+    @Test
+    public  void testArrayAndLinkedFunctions(){
+        double [] xValues1 = {1,2,3,4};
+        double [] yValues1 = {10,20,30,40};
+        double [] xValues2 = {1,2,3,4};
+        double [] yValues2 = {100,200,300,400};
+        ArrayTabulatedFunction func1 = new ArrayTabulatedFunction(xValues1,yValues1);
+        LinkedListTabulatedFunction func2 = new LinkedListTabulatedFunction(xValues2,yValues2);
+        CompositeFunction func = new CompositeFunction(func1,func2);
+        assertEquals(1000, func.apply(1), 0.001);
+    }
+
+    @Test
+    public void testInterpolationConsistencyBetweenImplementations() {
+
+        double[] xValues = {0.5, 1.7, 2.9, 4.1, 5.3};
+        double[] yValues = {2.3, 4.1, 1.8, 5.6, 3.2};
+
+        ArrayTabulatedFunction arrayFunc = new ArrayTabulatedFunction(xValues, yValues);
+        LinkedListTabulatedFunction linkedListFunc = new LinkedListTabulatedFunction(xValues, yValues);
+
+        double testX1 = 1.2;
+        double testX2 = 3.5;
+        double testX3 = 4.8;
+
+        assertEquals(arrayFunc.apply(testX1), linkedListFunc.apply(testX1), 1e-9);
+        assertEquals(arrayFunc.apply(testX2), linkedListFunc.apply(testX2), 1e-9);
+        assertEquals(arrayFunc.apply(testX3), linkedListFunc.apply(testX3), 1e-9);
+    }
+
+
+    @Test
+    public void testIndexSearchConsistency() {
+        // Проверка согласованности поиска индексов
+        double[] xValues = {1.3, 2.7, 4.2, 5.8, 7.1};
+        double[] yValues = {2.1, 4.8, 1.3, 5.9, 3.4};
+
+        ArrayTabulatedFunction arrayFunc = new ArrayTabulatedFunction(xValues, yValues);
+        LinkedListTabulatedFunction linkedListFunc = new LinkedListTabulatedFunction(xValues, yValues);
+
+        assertEquals(arrayFunc.indexOfX(2.7), linkedListFunc.indexOfX(2.7));
+        assertEquals(arrayFunc.indexOfX(5.8), linkedListFunc.indexOfX(5.8));
+        assertEquals(arrayFunc.indexOfX(3.0), linkedListFunc.indexOfX(3.0)); // не существует
+
+        assertEquals(arrayFunc.indexOfY(4.8), linkedListFunc.indexOfY(4.8));
+        assertEquals(arrayFunc.indexOfY(3.4), linkedListFunc.indexOfY(3.4));
+        assertEquals(arrayFunc.indexOfY(6.0), linkedListFunc.indexOfY(6.0)); // не существует
+
+        double testX1 = 3.5;
+        double testX2 = 6.5;
+
+        assertEquals(arrayFunc.apply(testX1), linkedListFunc.apply(testX1), 1e-9);
+        assertEquals(arrayFunc.apply(testX2), linkedListFunc.apply(testX2), 1e-9);
+    }
+
+    @Test
+    public void testSinglePointFunctionHandling() {
+        //Проверка обработки функции с одной точкой
+        double[] singleX = {2.5};
+        double[] singleY = {7.3};
+
+        ArrayTabulatedFunction arraySingle = new ArrayTabulatedFunction(singleX, singleY);
+        LinkedListTabulatedFunction linkedListSingle = new LinkedListTabulatedFunction(singleX, singleY);
+
+
+        assertEquals(7.3, arraySingle.apply(0.0), 1e-9);
+        assertEquals(7.3, arraySingle.apply(2.5), 1e-9);
+        assertEquals(7.3, arraySingle.apply(5.0), 1e-9);
+
+        assertEquals(linkedListSingle.apply(0.0), arraySingle.apply(0.0), 1e-9);
+        assertEquals(linkedListSingle.apply(2.5), arraySingle.apply(2.5), 1e-9);
+        assertEquals(linkedListSingle.apply(5.0), arraySingle.apply(5.0), 1e-9);
+    }
+}
\ No newline at end of file
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/LinkedListTabulatedFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/LinkedListTabulatedFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/LinkedListTabulatedFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254122)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/LinkedListTabulatedFunctionTest.java	(date 1759256254122)
@@ -0,0 +1,395 @@
+package ru.ssau.tk.pmi.functions.functions;
+
+import org.junit.jupiter.api.Test;
+
+import org.junit.jupiter.api.BeforeEach;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import ru.ssau.tk.pmi.functions.*;
+import ru.ssau.tk.pmi.functions.LinkedListTabulatedFunction.Node;
+
+import static org.junit.jupiter.api.Assertions.*;
+public class LinkedListTabulatedFunctionTest {
+
+    private LinkedListTabulatedFunction function;
+    private final double[] xValues = {1.3, 2.7, 4.1, 5.5, 6.9};
+    private final double[] yValues = {3.8, 7.2, 9.6, 12.4, 15.1};
+
+    @BeforeEach
+    public void setUp() {
+        function = new LinkedListTabulatedFunction(xValues, yValues);
+    }
+
+    // Тесты конструкторов
+    @Test
+    public void testConstructorFromArrays_ValidData_CreatesCorrectList() {
+        assertEquals(5, function.getCount());
+        assertEquals(1.3, function.leftBound(), 1e-9);
+        assertEquals(6.9, function.rightBound(), 1e-9);
+    }
+
+    @Test
+    public void testConstructorFromFunction_UniformSampling_CreatesCorrectList() {
+        MathFunction square = new SqrFunction();
+        LinkedListTabulatedFunction func = new LinkedListTabulatedFunction(square, 1.5, 3.5, 4);
+
+        assertEquals(4, func.getCount());
+        assertEquals(1.5, func.leftBound(), 1e-9);
+        assertEquals(3.5, func.rightBound(), 1e-9);
+        assertEquals(2.25, func.getY(0), 1e-9);
+        assertEquals(12.25, func.getY(3), 1e-9);
+    }
+
+    @Test
+    public void testConstructorFromFunction_ReversedBounds_CorrectsOrder() {
+        MathFunction identity = new IdentityFunction();
+        LinkedListTabulatedFunction func = new LinkedListTabulatedFunction(identity, 2.4, 7.2, 4);
+
+        assertEquals(2.4, func.leftBound(), 1e-9);
+        assertEquals(7.2, func.rightBound(), 1e-9);
+    }
+
+    @Test
+    public void testConstructorFromFunction_SinglePoint_AllValuesEqual() {
+        MathFunction constant = new ConstantFunction(8.7);
+        LinkedListTabulatedFunction func = new LinkedListTabulatedFunction(constant, 3.3, 3.3, 4);
+
+        assertEquals(4, func.getCount());
+        assertEquals(3.3, func.getX(0), 1e-9);
+        assertEquals(3.3, func.getX(1), 1e-9);
+        assertEquals(3.3, func.getX(2), 1e-9);
+        assertEquals(3.3, func.getX(3), 1e-9);
+        assertEquals(8.7, func.getY(0), 1e-9);
+        assertEquals(8.7, func.getY(1), 1e-9);
+        assertEquals(8.7, func.getY(2), 1e-9);
+        assertEquals(8.7, func.getY(3), 1e-9);
+    }
+
+    // Тесты основных методов доступа
+    @Test
+    public void testGetCount_AfterCreation_ReturnsCorrectCount() {
+        assertEquals(5, function.getCount());
+    }
+
+    @Test
+    public void testGetX_ValidIndex_ReturnsCorrectValue() {
+        assertEquals(1.3, function.getX(0), 1e-9);
+        assertEquals(2.7, function.getX(1), 1e-9);
+        assertEquals(4.1, function.getX(2), 1e-9);
+        assertEquals(5.5, function.getX(3), 1e-9);
+        assertEquals(6.9, function.getX(4), 1e-9);
+    }
+
+    @Test
+    public void testGetY_ValidIndex_ReturnsCorrectValue() {
+        assertEquals(3.8, function.getY(0), 1e-9);
+        assertEquals(7.2, function.getY(1), 1e-9);
+        assertEquals(9.6, function.getY(2), 1e-9);
+        assertEquals(12.4, function.getY(3), 1e-9);
+        assertEquals(15.1, function.getY(4), 1e-9);
+    }
+
+    @Test
+    public void testSetY_ValidIndex_ModifiesValue() {
+        function.setY(2, 11.3);
+        assertEquals(11.3, function.getY(2), 1e-9);
+        // Проверяем что другие значения не изменились
+        assertEquals(3.8, function.getY(0), 1e-9);
+        assertEquals(7.2, function.getY(1), 1e-9);
+        assertEquals(12.4, function.getY(3), 1e-9);
+    }
+
+    // Тесты граничных значений
+    @Test
+    public void testLeftBound_ReturnsFirstX() {
+        assertEquals(1.3, function.leftBound(), 1e-9);
+    }
+
+    @Test
+    public void testRightBound_ReturnsLastX() {
+        assertEquals(6.9, function.rightBound(), 1e-9);
+    }
+
+    // Тесты поиска
+    @Test
+    public void testIndexOfX_ExistingValue_ReturnsCorrectIndex() {
+        assertEquals(0, function.indexOfX(1.3));
+        assertEquals(1, function.indexOfX(2.7));
+        assertEquals(3, function.indexOfX(5.5));
+        assertEquals(4, function.indexOfX(6.9));
+    }
+
+    @Test
+    public void testIndexOfX_NonExistingValue_ReturnsMinusOne() {
+        assertEquals(-1, function.indexOfX(1.0));
+        assertEquals(-1, function.indexOfX(3.5));
+        assertEquals(-1, function.indexOfX(7.2));
+    }
+
+    @Test
+    public void testIndexOfY_ExistingValue_ReturnsCorrectIndex() {
+        assertEquals(0, function.indexOfY(3.8));
+        assertEquals(1, function.indexOfY(7.2));
+        assertEquals(3, function.indexOfY(12.4));
+        assertEquals(4, function.indexOfY(15.1));
+    }
+
+    @Test
+    public void testIndexOfY_NonExistingValue_ReturnsMinusOne() {
+        assertEquals(-1, function.indexOfY(2.5));
+        assertEquals(-1, function.indexOfY(8.9));
+        assertEquals(-1, function.indexOfY(16.0));
+    }
+
+    // Тесты floorIndexOfX
+    @Test
+    public void testFloorIndexOfX_LessThanAll_ReturnsZero() {
+        assertEquals(0, function.floorIndexOfX(0.8));
+    }
+
+    @Test
+    public void testFloorIndexOfX_GreaterThanAll_ReturnsCount() {
+        assertEquals(5, function.floorIndexOfX(7.5));
+    }
+
+    @Test
+    public void testFloorIndexOfX_BetweenNodes_ReturnsLeftIndex() {
+        assertEquals(0, function.floorIndexOfX(1.8));
+        assertEquals(1, function.floorIndexOfX(3.2));
+        assertEquals(2, function.floorIndexOfX(4.7));
+        assertEquals(3, function.floorIndexOfX(6.1));
+    }
+
+    @Test
+    public void testFloorIndexOfX_ExactMatch_ReturnsNodeIndex() {
+        assertEquals(0, function.floorIndexOfX(1.3));
+        assertEquals(2, function.floorIndexOfX(4.1));
+        assertEquals(4, function.floorIndexOfX(6.9));
+    }
+
+    // Тесты интерполяции
+    @Test
+    public void testInterpolate_BetweenNodes_ReturnsLinearValue() {
+        double result = function.interpolate(3.4, 1);
+        double expected = 7.2 + (9.6 - 7.2) * (3.4 - 2.7) / (4.1 - 2.7);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    @Test
+    public void testInterpolate_AnotherInterval_ReturnsCorrectValue() {
+        // Между 4.1 и 5.5: x=4.8
+        double result = function.interpolate(4.8, 2);
+        double expected = 9.6 + (12.4 - 9.6) * (4.8 - 4.1) / (5.5 - 4.1);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    // Тесты экстраполяции
+    @Test
+    public void testExtrapolateLeft_OutsideLeft_ReturnsCorrectValue() {
+        // Экстраполяция слева от 1.3
+        double result = function.extrapolateLeft(0.5);
+        double expected = 3.8 + (7.2 - 3.8) * (0.5 - 1.3) / (2.7 - 1.3);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    @Test
+    public void testExtrapolateRight_OutsideRight_ReturnsCorrectValue() {
+        // Экстраполяция справа от 6.9
+        double result = function.extrapolateRight(7.8);
+        double expected = 12.4 + (15.1 - 12.4) * (7.8 - 5.5) / (6.9 - 5.5);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    // Тесты метода apply()
+    @Test
+    public void testApply_ExactNodeMatch_ReturnsNodeValue() {
+        assertEquals(3.8, function.apply(1.3), 1e-9);
+        assertEquals(7.2, function.apply(2.7), 1e-9);
+        assertEquals(15.1, function.apply(6.9), 1e-9);
+    }
+
+    @Test
+    public void testApply_BetweenNodes_ReturnsInterpolatedValue() {
+        // Между 2.7 и 4.1
+        double result = function.apply(3.4);
+        double expected = 7.2 + (9.6 - 7.2) * (3.4 - 2.7) / (4.1 - 2.7);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    @Test
+    public void testApply_LeftExtrapolation_ReturnsExtrapolatedValue() {
+        double result = function.apply(0.8);
+        double expected = 3.8 + (7.2 - 3.8) * (0.8 - 1.3) / (2.7 - 1.3);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    @Test
+    public void testApply_RightExtrapolation_ReturnsExtrapolatedValue() {
+        double result = function.apply(7.3);
+        double expected = 12.4 + (15.1 - 12.4) * (7.3 - 5.5) / (6.9 - 5.5);
+        assertEquals(expected, result, 1e-9);
+    }
+
+    // Тесты специальных случаев
+    @Test
+    public void testTwoNodeList_AllMethodsWork() {
+        double[] twoX = {2.1, 5.7};
+        double[] twoY = {4.3, 11.9};
+        LinkedListTabulatedFunction twoNodeFunc = new LinkedListTabulatedFunction(twoX, twoY);
+
+        assertEquals(2, twoNodeFunc.getCount());
+        assertEquals(2.1, twoNodeFunc.leftBound(), 1e-9);
+        assertEquals(5.7, twoNodeFunc.rightBound(), 1e-9);
+
+        // Проверяем интерполяцию
+        double interpolated = twoNodeFunc.apply(3.9);
+        double expected = 4.3 + (11.9 - 4.3) * (3.9 - 2.1) / (5.7 - 2.1);
+        assertEquals(expected, interpolated, 1e-9);
+    }
+
+    @Test
+    public void testFloorNodeOfX_VariousCases_ReturnsCorrectNode() {
+        Node node = function.floorNodeOfX(1.8);
+        assertNotNull(node);
+        assertEquals(1.3, node.x, 1e-9);
+
+        node = function.floorNodeOfX(3.2);
+        assertEquals(2.7, node.x, 1e-9);
+
+        node = function.floorNodeOfX(6.1);
+        assertEquals(5.5, node.x, 1e-9);
+    }
+
+    @Test
+    public void testApply_WithOptimizedSearch_ReturnsCorrectValues() {
+        assertEquals(3.8, function.apply(1.3), 1e-9);
+        assertEquals(8.4, function.apply(3.4), 1e-9);
+
+        double leftExtrapolation = function.apply(0.5);
+        double rightExtrapolation = function.apply(7.8);
+        assertTrue(leftExtrapolation < 3.8);
+        assertTrue(rightExtrapolation > 15.1);
+    }
+
+    @Test
+    public void testApply_ExactMatch_ReturnsNodeValueWithoutInterpolation() {
+        assertEquals(7.2, function.apply(2.7), 1e-9);
+        assertEquals(12.4, function.apply(5.5), 1e-9);
+    }
+    @Test
+    void testInsertIntoEmptyList() {
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(new double[0], new double[0]);
+        function.insert(2.0, 4.0);
+        assertEquals(1, function.getCount());
+        assertEquals(2.0, function.getX(0));
+        assertEquals(4.0, function.getY(0));
+    }
+    @Test
+    void testInsertAtBeginning() {
+        // Создаем: (1,1) → (3,9) → (5,25)
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(
+                new double[]{1.0, 3.0, 5.0},
+                new double[]{1.0, 9.0, 25.0}
+        );
+        function.insert(-1.0, 1.0);  // Вставляем -1,1 в начало
+        assertEquals(4, function.getCount());
+        assertEquals(-1.0, function.getX(0));
+        assertEquals(1.0, function.getX(1));
+        assertEquals(1.0, function.getY(0));
+    }
+    @Test
+    void testInsertAtEnd() {
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(
+                new double[]{1.0, 3.0, 5.0},
+                new double[]{1.0, 9.0, 25.0}
+        );
+        function.insert(7.0, 49.0);  // Вставляем 7,49 в конец
+        assertEquals(4, function.getCount());
+        assertEquals(5.0, function.getX(2));
+        assertEquals(7.0, function.getX(3));
+        assertEquals(49.0, function.getY(3));
+
+    }
+    @Test
+    void testInsertInMiddle() {
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(
+                new double[]{1.0, 3.0, 5.0},
+                new double[]{1.0, 9.0, 25.0}
+        );
+        function.insert(2.0, 4.0);  // Вставляем 2,4 между 1 и 3
+        assertEquals(4, function.getCount());
+        assertEquals(1.0, function.getX(0));
+        assertEquals(2.0, function.getX(1));
+        assertEquals(3.0, function.getX(2));
+        assertEquals(5.0, function.getX(3));
+        assertEquals(4.0, function.getY(1));
+    }
+    @Test
+    void testUpdateExistingX() {
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(
+                new double[]{1.0, 3.0, 5.0},
+                new double[]{1.0, 9.0, 25.0}
+        );
+        function.insert(3.0, 100.0);  // Обновляем существующий X=3.0
+        assertEquals(3, function.getCount());  // Количество не изменилось
+        assertEquals(3.0, function.getX(1));   // X остался тот же
+        assertEquals(100.0, function.getY(1)); // Y обновился
+    }
+
+    @Test
+    public void removeTestMiddle() {
+        double[] xValue = {2.1, 5.7, 8};
+        double[] yValue = {4.3, 11.9, 78};
+        LinkedListTabulatedFunction func = new LinkedListTabulatedFunction(xValue, yValue);
+
+        func.remove(1);
+        assertEquals(2, func.getCount());
+        assertEquals(8, func.getX(1), 1e-9);
+        assertEquals(78, func.getY(1), 1e-9);
+    }
+
+    @Test
+    public void testRemoveFromBeginning() {
+        // Удаление первого элемента
+        double[] xValues = {1.5, 2.5, 3.5};
+        double[] yValues = {15.0, 25.0, 35.0};
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(xValues, yValues);
+
+        function.remove(0);
+
+        assertEquals(2, function.getCount());
+        assertEquals(2.5, function.getX(0), 1e-9);
+        assertEquals(3.5, function.getX(1), 1e-9);
+        assertEquals(25.0, function.getY(0), 1e-9);
+        assertEquals(35.0, function.getY(1), 1e-9);
+    }
+
+
+    @Test
+    public void testRemoveFromEnd() {
+        //Удаление последнего элемента
+        double[] xValues = {1.2, 2.4, 3.6};
+        double[] yValues = {12.0, 24.0, 36.0};
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(xValues, yValues);
+
+        function.remove(2);
+
+        assertEquals(2, function.getCount());
+        assertEquals(1.2, function.getX(0), 1e-9);
+        assertEquals(2.4, function.getX(1), 1e-9);
+        assertEquals(12.0, function.getY(0), 1e-9);
+        assertEquals(24.0, function.getY(1), 1e-9);
+    }
+
+    @Test
+    public void testRemoveSingleElement() {
+        // Удаление единственного элемента
+        double[] xValues = {5.0};
+        double[] yValues = {50.0};
+        LinkedListTabulatedFunction function = new LinkedListTabulatedFunction(xValues, yValues);
+
+        function.remove(0);
+        assertEquals(0, function.getCount());
+    }
+}
\ No newline at end of file
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/IdentityFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/IdentityFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/IdentityFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254072)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/IdentityFunctionTest.java	(date 1759256254072)
@@ -0,0 +1,19 @@
+package ru.ssau.tk.pmi.functions.functions;
+
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.IdentityFunction;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+class IdentityFunctionTest {
+
+    @Test
+    public void testApply() {
+        IdentityFunction func = new IdentityFunction();
+        assertEquals(456, func.apply(456), 1e-9);
+        assertEquals(0.0, func.apply(0.0), 1e-9);
+        assertEquals(-3.5, func.apply(-3.5), 1e-9);
+        assertEquals(-7.569, func.apply(-7.569), 1e-9);
+        assertEquals(67.8, func.apply(67.8), 1e-9);
+    }
+}
\ No newline at end of file
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/SqrFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/SqrFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/SqrFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254132)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/SqrFunctionTest.java	(date 1759256254132)
@@ -0,0 +1,24 @@
+package ru.ssau.tk.pmi.functions.functions;
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.SqrFunction;
+
+import static org.junit.jupiter.api.Assertions.*;
+class SqrFunctionTest {
+    @Test
+    public void testApply() {
+        SqrFunction sqrFunction = new SqrFunction();
+        assertEquals(0.0, sqrFunction.apply(0.0));
+        assertEquals(1.0, sqrFunction.apply(1.0));
+        assertEquals(4.0, sqrFunction.apply(2.0));
+        assertEquals(36.0, sqrFunction.apply(6.0));
+        assertEquals(25.0, sqrFunction.apply(5.0));
+        assertEquals(4.0, sqrFunction.apply(-2.0));
+        assertEquals(9.0, sqrFunction.apply(-3.0));
+        assertEquals(16.0, sqrFunction.apply(-4.0));
+        assertEquals(25.0, sqrFunction.apply(-5.0));
+        assertEquals(64.0, sqrFunction.apply(-8.0));
+        assertEquals(61.7796, sqrFunction.apply(-7.86), 0.0000001);
+        assertEquals(0.25, sqrFunction.apply(0.5), 0.0000001);
+        assertEquals(2.25, sqrFunction.apply(1.5), 0.0000001);
+    }
+}
\ No newline at end of file
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/SimpleIterationMethodTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/SimpleIterationMethodTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/SimpleIterationMethodTest.java
new file mode 100644
--- /dev/null	(date 1759256254081)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/SimpleIterationMethodTest.java	(date 1759256254081)
@@ -0,0 +1,122 @@
+package ru.ssau.tk.pmi.functions.functions;
+
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.MathFunction;
+import ru.ssau.tk.pmi.functions.SimpleIterationMethod;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+public class SimpleIterationMethodTest {
+
+    // Вспомогательные классы функций
+    static class CosFunction implements MathFunction {
+        public double apply(double x) {
+            return Math.cos(x);
+        }
+    }
+
+    static class SqrtFunction implements MathFunction {
+        public double apply(double x) {
+            return (x + 2.0 / x) / 2.0;
+        }
+    }
+
+    static class IdentityFunction implements MathFunction {
+        public double apply(double x) {
+            return x;
+        }
+    }
+
+    static class ConstantFunction implements MathFunction {
+        public double apply(double x) {
+            return 42.0;
+        }
+    }
+
+    static class SlowConvergenceFunction implements MathFunction {
+        public double apply(double x) {
+            return x + 0.001;
+        }
+    }
+
+    static class LinearFunction implements MathFunction {
+        public double apply(double x) {
+            return 0.5 * x + 1;
+        }
+    }
+
+    @Test
+    public void testSolveCosEquation() {
+        MathFunction cosFunction = new CosFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 1000, cosFunction);
+        double result = solver.apply(0.5);
+
+        assertEquals(0.739085, result, 0.001);
+    }
+
+    @Test
+    public void testSolveSquareRootOfTwo() {
+        MathFunction sqrtFunction = new SqrtFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 1000, sqrtFunction);
+        double result = solver.apply(1.0);
+
+        assertEquals(1.41421356, result, 0.0001);
+    }
+
+    @Test
+    public void testIdentityFunctionConvergesImmediately() {
+        MathFunction identity = new IdentityFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 1000, identity);
+        double result = solver.apply(5.0);
+
+        assertEquals(5.0, result, 0.0001);
+    }
+
+    @Test
+    public void testConstantFunction() {
+        MathFunction constant = new ConstantFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 1000, constant);
+        double result = solver.apply(10.0);
+
+        assertEquals(42.0, result, 0.0001);
+    }
+
+    @Test
+    public void testRespectsPrecision() {
+        MathFunction cosFunction = new CosFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.01, 1000, cosFunction);
+        double result = solver.apply(0.5);
+
+        double next = cosFunction.apply(result);
+        assertTrue(Math.abs(next - result) < 0.02);
+    }
+
+    @Test
+    public void testMaxIterationsReached() {
+        MathFunction slowConvergence = new SlowConvergenceFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 10, slowConvergence);
+        double result = solver.apply(0.0);
+
+        assertTrue(result >= 0.0 && result <= 0.1);
+    }
+
+    @Test
+    public void testDifferentInitialGuess() {
+        MathFunction cosFunction = new CosFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 1000, cosFunction);
+
+        double result1 = solver.apply(0.1);
+        double result2 = solver.apply(1.0);
+
+        assertEquals(result1, result2, 0.001);
+    }
+
+    @Test
+    public void testLinearFunction() {
+        MathFunction linear = new LinearFunction();
+        SimpleIterationMethod solver = new SimpleIterationMethod(0.0001, 1000, linear);
+        double result = solver.apply(0.0);
+
+        assertEquals(2.0, result, 0.0001);
+    }
+}
\ No newline at end of file
Index: src/main/java/ru/ssau/tk/pmi/functions/AbstractTabulatedFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/AbstractTabulatedFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/AbstractTabulatedFunction.java
new file mode 100644
--- /dev/null	(date 1759255994776)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/AbstractTabulatedFunction.java	(date 1759255994776)
@@ -0,0 +1,28 @@
+package ru.ssau.tk.pmi.functions;
+
+public abstract class AbstractTabulatedFunction implements TabulatedFunction{
+    protected abstract int floorIndexOfX(double x);
+    protected abstract double extrapolateLeft(double x);
+    protected abstract double extrapolateRight(double x);
+    protected abstract double interpolate(double x, int floorIndex);
+    protected double interpolate(double x, double leftX, double rightX, double leftY, double rightY) {
+        return leftY + (rightY - leftY) * (x - leftX) / (rightX - leftX);
+    }
+
+    @Override
+    public double apply(double x) {
+        if (x < leftBound())
+            return extrapolateLeft(x);
+        if (x > rightBound())
+            return extrapolateRight(x);
+        int index = indexOfX(x);
+        if (index != -1) {
+            return getY(index);
+        }
+        else {
+            int floorIndex = floorIndexOfX(x);
+            return interpolate(x, floorIndex);
+        }
+    }
+}
+
Index: src/main/java/ru/ssau/tk/pmi/functions/BSplineFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/BSplineFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/BSplineFunction.java
new file mode 100644
--- /dev/null	(date 1759255994851)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/BSplineFunction.java	(date 1759255994851)
@@ -0,0 +1,128 @@
+package ru.ssau.tk.pmi.functions;
+
+public class BSplineFunction implements MathFunction {
+    private final double[] nodePoints;     // Точки узлов
+    private final int splineOrder;         // Порядок сплайна
+    private final double[] weights;        // Весовые коэффициенты
+
+    //конструктор
+    public BSplineFunction(double[] nodePoints, int splineOrder, double[] weights) {
+
+        this.nodePoints = nodePoints.clone();
+        this.splineOrder = splineOrder;
+        this.weights = weights.clone();
+    }
+
+    @Override
+    public double apply(double x) {
+        return computeSplineValue(x);
+    }
+
+     //Вычисление значения сплайна в заданной точке
+    private double computeSplineValue(double x) {
+        int segmentIndex = locateSegment(x);
+
+        if (segmentIndex < splineOrder) {
+            return 0.0; // Точка лежит слева от области определения
+        }
+        if (segmentIndex >= nodePoints.length - splineOrder - 1) {
+            return 0.0; // Точка лежит справа от области определения
+        }
+
+        double total = 0.0;
+        for (int i = segmentIndex - splineOrder; i <= segmentIndex; i++) {
+            double basisValue = computeBasis(i, splineOrder, x);
+            total += weights[i] * basisValue;
+        }
+
+        return total;
+    }
+
+     //Рекурсивный расчет базисной функции
+    private double computeBasis(int idx, int order, double x) {
+        if (order == 0) {
+            // Базовый случай - функция нулевого порядка
+            return (x >= nodePoints[idx] && x < nodePoints[idx + 1]) ? 1.0 : 0.0;
+        }
+
+        double firstPart = 0.0;
+        double secondPart = 0.0;
+
+        // Первая составляющая рекурсии
+        double div1 = nodePoints[idx + order] - nodePoints[idx];
+        if (div1 != 0.0) {
+            double ratio1 = (x - nodePoints[idx]) / div1;
+            firstPart = ratio1 * computeBasis(idx, order - 1, x);
+        }
+
+        // Вторая составляющая рекурсии
+        double div2 = nodePoints[idx + order + 1] - nodePoints[idx + 1];
+        if (div2 != 0.0) {
+            double ratio2 = (nodePoints[idx + order + 1] - x) / div2;
+            secondPart = ratio2 * computeBasis(idx + 1, order - 1, x);
+        }
+
+        return firstPart + secondPart;
+    }
+
+     //Определение сегмента, содержащего точку x
+    private int locateSegment(double x) {
+        if (x < nodePoints[0] || x > nodePoints[nodePoints.length - 1]) {
+            return -1;
+        }
+
+        int left = 0;
+        int right = nodePoints.length - 2;
+
+        while (left <= right) {
+            int middle = (left + right) / 2;
+            if (x < nodePoints[middle]) {
+                right = middle - 1;
+            } else if (x >= nodePoints[middle + 1]) {
+                left = middle + 1;
+            } else {
+                return middle;
+            }
+        }
+
+        return right;
+    }
+
+    public double[] getNodePoints() {
+        return nodePoints.clone();
+    }
+
+    public int getSplineOrder() {
+        return splineOrder;
+    }
+
+    public double[] getWeights() {
+        return weights.clone();
+    }
+
+
+     //Создание сплайна с равномерными узлами
+    public static BSplineFunction buildUniformSpline(double from, double to,int order, int pointCount,double[] weights) {
+        if (pointCount <= order) {
+            throw new IllegalArgumentException("Количество точек должно превышать порядок");
+        }
+
+        int totalNodes = pointCount + order + 1;
+        double[] nodes = new double[totalNodes];
+
+        // Формирование узлового вектора
+        for (int i = 0; i < totalNodes; i++) {
+            if (i <= order) {
+                nodes[i] = from;
+            } else if (i >= pointCount) {
+                nodes[i] = to;
+            } else {
+                double position = (double) (i - order) / (pointCount - order);
+                nodes[i] = from + position * (to - from);
+            }
+        }
+
+        return new BSplineFunction(nodes, order, weights);
+    }
+
+}
\ No newline at end of file
Index: src/main/java/ru/ssau/tk/pmi/functions/ArrayTabulatedFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/ArrayTabulatedFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/ArrayTabulatedFunction.java
new file mode 100644
--- /dev/null	(date 1759255994825)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/ArrayTabulatedFunction.java	(date 1759255994825)
@@ -0,0 +1,160 @@
+package ru.ssau.tk.pmi.functions;
+import java.util.Arrays;
+public class ArrayTabulatedFunction extends AbstractTabulatedFunction implements Insertable, Removable{
+    private double[] xValues;
+    private double[] yValues;
+    private int count;
+    public ArrayTabulatedFunction(double[] xValues, double[] yValues) {
+        this.xValues = Arrays.copyOf(xValues, xValues.length);
+        this.yValues = Arrays.copyOf(yValues, yValues.length);
+        this.count = xValues.length;
+    }
+    public ArrayTabulatedFunction(MathFunction source, double xFrom, double xTo, int count) {
+        this.count = count;
+        this.xValues = new double[count];
+        this.yValues = new double[count];
+        if (xFrom > xTo) {
+            double temp = xFrom;
+            xFrom = xTo;
+            xTo = temp;
+        }
+        if (xFrom == xTo) {
+            double value = source.apply(xFrom);
+            Arrays.fill(xValues, xFrom);
+            Arrays.fill(yValues, value);
+        } else {
+            double step = (xTo - xFrom) / (count - 1);
+            for (int i = 0; i < count; i++) {
+                xValues[i] = xFrom + i * step;
+                yValues[i] = source.apply(xValues[i]);
+            }
+        }
+    }
+    @Override
+    public int getCount() {
+        return count;
+    }
+    @Override
+    public double getX(int index) {
+        return xValues[index];
+    }
+    @Override
+    public double getY(int index) {
+        return yValues[index];
+    }
+    @Override
+    public void setY(int index, double value) {
+        yValues[index] = value;
+    }
+    @Override
+    public int indexOfX(double x) {
+        for (int i = 0; i < count; i++) {
+            if (xValues[i] == x) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    @Override
+    public int indexOfY(double y) {
+        for (int i = 0; i < count; i++) {
+            if (yValues[i] == y) {
+                return i;
+            }
+        }
+        return -1;
+    }
+    @Override
+    public double leftBound() {
+        return xValues[0];
+    }
+    @Override
+    public double rightBound() {
+        return xValues[count - 1];
+    }
+    @Override
+    protected int floorIndexOfX(double x) {
+        if (x < xValues[0]) {
+            return 0;
+        }
+        if (x >= xValues[count - 1]) {
+            return count;
+        }
+        for (int i = 0; i < count - 1; i++) {
+            if (x >= xValues[i] && x < xValues[i + 1]) {
+                return i;
+            }
+        }
+        return count - 2;
+    }
+    @Override
+    protected double extrapolateLeft(double x) {
+        if (count == 1) {
+            return yValues[0];
+        }
+        return interpolate(x, xValues[0], xValues[1], yValues[0], yValues[1]);
+    }
+    @Override
+    protected double extrapolateRight(double x) {
+        if (count == 1) {
+            return yValues[0];
+        }
+        return interpolate(x, xValues[count - 2], xValues[count - 1], yValues[count - 2], yValues[count - 1]);
+    }
+    @Override
+    protected double interpolate(double x, int floorIndex) {
+        if (count == 1) {
+            return yValues[0];
+        }
+        return interpolate(x, xValues[floorIndex], xValues[floorIndex + 1], yValues[floorIndex], yValues[floorIndex + 1]);
+    }
+
+    public void insert(double x, double y){
+
+        int index = indexOfX(x);
+
+        if (index == -1){
+
+            int floorInd; //позиция для вставки
+            if (x < xValues[0]) {
+                floorInd = 0;
+            } else if (x > xValues[count - 1]) {
+                floorInd = count;
+            } else {
+                floorInd = floorIndexOfX(x) + 1;
+            }
+
+
+            double[] newXValues = new double[count+1];
+            double[] newYValues = new double[count+1];
+            System.arraycopy(xValues, 0, newXValues, 0, floorInd);
+            newXValues[floorInd] = x;
+            System.arraycopy(xValues, floorInd , newXValues, floorInd + 1, count - floorInd);
+
+            System.arraycopy(yValues, 0, newYValues, 0, floorInd);
+            newYValues[floorInd] = y;
+            System.arraycopy(yValues, floorInd , newYValues, floorInd + 1, count - floorInd);
+
+            this.xValues = newXValues;
+            this.yValues = newYValues;
+            this.count ++;
+        }
+
+        else{
+            yValues[index] = y;
+        }
+    }
+
+
+    public void remove(int index) {
+        if (index < 0 || index >= count) {
+            return;
+        }
+        for (int i = index; i < count - 1; i++) {
+            xValues[i] = xValues[i + 1];
+            yValues[i] = yValues[i + 1];
+        }
+        count--;
+    }
+}
+
Index: src/main/java/ru/ssau/tk/pmi/functions/ConstantFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/ConstantFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/ConstantFunction.java
new file mode 100644
--- /dev/null	(date 1759255994676)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/ConstantFunction.java	(date 1759255994676)
@@ -0,0 +1,15 @@
+package ru.ssau.tk.pmi.functions;
+
+public class ConstantFunction implements MathFunction {
+    private final double constant;
+    public ConstantFunction(double constant){
+        this.constant=constant;
+    }
+    @Override
+    public double apply(double x) {
+        return constant;
+    }
+    public double getConstant() {
+        return constant;
+    }
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/CompositeFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/CompositeFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/CompositeFunction.java
new file mode 100644
--- /dev/null	(date 1759255994879)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/CompositeFunction.java	(date 1759255994879)
@@ -0,0 +1,20 @@
+package ru.ssau.tk.pmi.functions;
+
+public class CompositeFunction implements MathFunction {
+    private final MathFunction firstFunction;
+    private final MathFunction secondFunction;
+    public CompositeFunction(MathFunction firstFunction, MathFunction secondFunction) {
+        this.firstFunction = firstFunction;
+        this.secondFunction = secondFunction;
+    }
+    @Override
+    public double apply(double x) {
+        return secondFunction.apply(firstFunction.apply(x));
+    }
+    public MathFunction getFirstFunction() {
+        return firstFunction;
+    }
+    public MathFunction getSecondFunction() {
+        return secondFunction;
+    }
+}
\ No newline at end of file
Index: src/main/java/ru/ssau/tk/pmi/functions/Insertable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/Insertable.java b/src/main/java/ru/ssau/tk/pmi/functions/Insertable.java
new file mode 100644
--- /dev/null	(date 1759255994703)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/Insertable.java	(date 1759255994703)
@@ -0,0 +1,5 @@
+package ru.ssau.tk.pmi.functions;
+
+public interface Insertable {
+    public void insert(double x,double y);
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/IdentityFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/IdentityFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/IdentityFunction.java
new file mode 100644
--- /dev/null	(date 1759255994792)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/IdentityFunction.java	(date 1759255994792)
@@ -0,0 +1,7 @@
+package ru.ssau.tk.pmi.functions;
+
+public class IdentityFunction implements MathFunction {
+    public double apply(double x){
+        return x;
+    }
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/MathFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/MathFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/MathFunction.java
new file mode 100644
--- /dev/null	(date 1759255994714)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/MathFunction.java	(date 1759255994714)
@@ -0,0 +1,8 @@
+package ru.ssau.tk.pmi.functions;
+
+public interface MathFunction {
+    double apply(double x);
+    default CompositeFunction andThen(MathFunction afterFunction) {
+        return new CompositeFunction(this, afterFunction);
+    }
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/LinkedListTabulatedFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/LinkedListTabulatedFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/LinkedListTabulatedFunction.java
new file mode 100644
--- /dev/null	(date 1759255994864)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/LinkedListTabulatedFunction.java	(date 1759255994864)
@@ -0,0 +1,290 @@
+package ru.ssau.tk.pmi.functions;
+
+public class LinkedListTabulatedFunction extends AbstractTabulatedFunction implements Insertable, Removable{
+
+    static class Node {
+        public double x;
+        public double y;
+        public Node next;
+        public Node prev;
+    }
+
+    private int count = 0;
+    private Node head = null;
+    private void addNode(double x, double y) //добавление узла
+    {
+        Node newNode = new Node();
+        newNode.x = x;
+        newNode.y = y;
+        if (head == null)
+        {
+            head = newNode;
+            head.prev = head;
+            head.next = head;
+        }
+
+        else{
+            Node last = head.prev;
+            last.next = newNode;
+            newNode.prev = last;
+            newNode.next = head;
+            head.prev = newNode;
+        }
+
+        count += 1;
+    }
+
+    private Node getNode(int index){
+        Node temp = head;
+        int i = 0;
+        while(i < index){
+            temp = temp.next;
+            i++;
+        }
+        return temp;
+    }
+
+    public LinkedListTabulatedFunction(double[] xValues, double [] yValues){
+        for (int i = 0; i < xValues.length; i++){
+            addNode(xValues[i], yValues[i]);
+        }
+    }
+
+    public LinkedListTabulatedFunction(MathFunction source, double xFrom, double xTo, int count){
+
+        if (xFrom == xTo) {
+            double yValue = source.apply(xFrom);
+            for (int i = 0; i < count; i++) {
+                addNode(xFrom, yValue);
+            }
+        }
+
+        else {
+            double step = (xTo - xFrom) / (count - 1);
+            for (int i = 0; i < count; i++) {
+                double x = xFrom + i * step;
+                double y = source.apply(x);
+                addNode(x, y);
+            }
+        }
+    }
+
+    public int getCount() {
+        return count;
+    }
+
+    public double leftBound(){
+        return head.x;
+    }
+
+    public double rightBound(){
+        return head.prev.x;
+    }
+
+    public double getX(int index){
+        return getNode(index).x;
+    }
+
+    public double getY(int index){
+        return getNode(index).y;
+    }
+
+    public void setY(int index, double value){
+        getNode(index).y = value;
+    }
+
+
+    public int indexOfX(double x) {
+        if (head == null) return -1;
+
+        Node current = head;
+        for (int i = 0; i < count; i++) {
+            if (current.x == x) {
+                return i;
+            }
+            current = current.next;
+        }
+        return -1;
+    }
+
+
+    public int indexOfY(double y) {
+        if (head == null) return -1;
+
+        Node current = head;
+        for (int i = 0; i < count; i++) {
+            if (current.y == y) {
+                return i;
+            }
+            current = current.next;
+        }
+        return -1;
+    }
+
+
+
+    protected int floorIndexOfX(double x) {
+        if (head == null) return 0;
+        if (x < head.x) return 0;
+        if (x > head.prev.x) return count;
+
+        Node current = head;
+        for (int i = 0; i < count - 1; i++) {
+            if (x >= current.x && x < current.next.x) {
+                return i;
+            }
+            current = current.next;
+        }
+        return count - 1;
+    }
+
+
+
+    protected double interpolate(double x, int floorIndex) {
+        if (count == 1) {
+            return head.y;
+        }
+
+        Node leftNode = getNode(floorIndex);
+        Node rightNode;
+
+        if (floorIndex == count - 1) {
+            rightNode = head;
+        } else {
+            rightNode = getNode(floorIndex + 1);
+        }
+
+        return interpolate(x, leftNode.x, rightNode.x, leftNode.y, rightNode.y);
+    }
+
+
+    protected double  extrapolateLeft(double x){
+        if (count < 2) {
+            return head.y;
+        }
+        return interpolate(x, head.x, head.next.x, head.y, head.next.y);
+    }
+
+    protected double extrapolateRight(double x) {
+        if (count < 2) {
+            return head.y;
+        }
+        Node last = head.prev;
+        Node prevLast = last.prev;
+        return interpolate(x, prevLast.x, last.x, prevLast.y, last.y);
+    }
+
+    @Override
+    public double apply(double x) {
+        if (x < leftBound()) {
+            return extrapolateLeft(x);
+        }
+
+        if (x > rightBound()) {
+            return extrapolateRight(x);
+        }
+
+
+        int exactIndex = indexOfX(x);
+        if (exactIndex != -1) {
+            return getY(exactIndex);
+        }
+
+        Node floorNode = floorNodeOfX(x);
+        return interpolateFromNode(x, floorNode);
+    }
+
+
+    protected Node floorNodeOfX(double x) {
+        if (head == null) return null;
+        if (x < head.x) return head;
+        if (x > head.prev.x) return head.prev;
+
+        Node current = head;
+        for (int i = 0; i < count; i++) {
+            if (x >= current.x && (current.next == head || x < current.next.x)) {
+                return current;
+            }
+            current = current.next;
+        }
+        return head.prev;
+    }
+
+
+    protected double interpolateFromNode(double x, Node leftNode) {
+        if (count == 1) {
+            return head.y;
+        }
+
+        Node rightNode = (leftNode.next == head) ? head.next : leftNode.next;
+        return interpolate(x, leftNode.x, rightNode.x, leftNode.y, rightNode.y);
+    }
+    public void insert(double x, double y){
+        if(head == null){
+            addNode(x, y);
+            return;
+        }
+        Node temp = head;
+        do{
+            if(x == temp.x){
+                temp.y = y;
+                return;
+            }
+            if(x>temp.x && x< temp.next.x ){
+                Node newNode = new Node();
+                newNode.x = x;
+                newNode.y = y;
+                Node node1 = temp;
+                Node node2 = temp.next;
+                node1.next = newNode;
+                node2.prev = newNode;
+                newNode.prev = node1;
+                newNode.next = node2;
+                count++;
+                return;
+            }
+            if(x>temp.x && temp.next== head ){
+                addNode(x,y);
+                return;
+            }
+
+            if(x< temp.x && temp==head){
+                Node newNode = new Node();
+                newNode.x = x;
+                newNode.y = y;
+                Node prev = temp.prev;
+                newNode.next = temp;
+                newNode.prev = prev;
+                prev.next = newNode;
+                temp.prev = newNode;
+                head = newNode;
+                count++;
+                return;
+            }
+            temp = temp.next;
+        }while (temp!= head);
+    }
+
+    public void remove(int index){
+        if (head == null || index < 0 || index >= count) return;
+
+        else{
+            if (count == 1) {
+                head = null;
+                count --;
+                return;
+            }
+
+            Node temp = getNode(index);
+            temp.prev.next = temp.next;
+            temp.next.prev = temp.prev;
+            if (index == 0){
+                head = temp.next;
+            }
+            count --;
+            temp.prev = null;
+            temp.next = null;
+        }
+    }
+
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/SimpleIterationMethod.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/SimpleIterationMethod.java b/src/main/java/ru/ssau/tk/pmi/functions/SimpleIterationMethod.java
new file mode 100644
--- /dev/null	(date 1759255994834)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/SimpleIterationMethod.java	(date 1759255994834)
@@ -0,0 +1,25 @@
+package ru.ssau.tk.pmi.functions;
+
+public class SimpleIterationMethod implements MathFunction {
+    private  final double precision;
+    private final int maxIterations;
+    private final MathFunction phifunction;
+    public SimpleIterationMethod(double precision, int maxIterations, MathFunction phifunction){
+        this.maxIterations = maxIterations;
+        this.phifunction= phifunction;
+        this.precision= precision;
+    }
+    public double apply(double x0){
+        double current = x0;
+        double next;
+        for(int i=0;i<maxIterations;i++){
+            next = phifunction.apply(current);
+            if(java.lang.Math.abs(next - current) < precision){
+                return next;
+            }
+            current = next;
+        }
+        return current;
+    }
+}
+
Index: src/main/java/ru/ssau/tk/pmi/functions/Removable.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/Removable.java b/src/main/java/ru/ssau/tk/pmi/functions/Removable.java
new file mode 100644
--- /dev/null	(date 1759255994870)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/Removable.java	(date 1759255994870)
@@ -0,0 +1,5 @@
+package ru.ssau.tk.pmi.functions;
+
+public interface Removable {
+    public void remove(int index);
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/TabulatedFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/TabulatedFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/TabulatedFunction.java
new file mode 100644
--- /dev/null	(date 1759255994843)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/TabulatedFunction.java	(date 1759255994843)
@@ -0,0 +1,12 @@
+package ru.ssau.tk.pmi.functions;
+
+public interface TabulatedFunction extends MathFunction{
+    int getCount();
+    double getX(int index);
+    double getY(int index);
+    void setY(int index, double value);
+    int indexOfX(double x);
+    int indexOfY(double y);
+    double leftBound();
+    double rightBound();
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/SqrFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/SqrFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/SqrFunction.java
new file mode 100644
--- /dev/null	(date 1759255994724)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/SqrFunction.java	(date 1759255994724)
@@ -0,0 +1,7 @@
+package ru.ssau.tk.pmi.functions;
+public class SqrFunction implements MathFunction{
+        public double apply(double x) {
+            return java.lang.Math.pow(x, 2);
+        }
+}
+
Index: src/main/java/ru/ssau/tk/pmi/functions/ZeroFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/ZeroFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/ZeroFunction.java
new file mode 100644
--- /dev/null	(date 1759255994670)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/ZeroFunction.java	(date 1759255994670)
@@ -0,0 +1,7 @@
+package ru.ssau.tk.pmi.functions;
+
+public class ZeroFunction extends ConstantFunction {
+    public ZeroFunction(){
+        super(0.0);
+    }
+}
Index: src/main/java/ru/ssau/tk/pmi/functions/UnitFunction.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/ru/ssau/tk/pmi/functions/UnitFunction.java b/src/main/java/ru/ssau/tk/pmi/functions/UnitFunction.java
new file mode 100644
--- /dev/null	(date 1759255994742)
+++ b/src/main/java/ru/ssau/tk/pmi/functions/UnitFunction.java	(date 1759255994742)
@@ -0,0 +1,7 @@
+package ru.ssau.tk.pmi.functions;
+
+public class UnitFunction extends ConstantFunction{
+    public UnitFunction(){
+        super(1.0);
+    }
+}
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/BSplineFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/BSplineFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/BSplineFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254143)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/BSplineFunctionTest.java	(date 1759256254143)
@@ -0,0 +1,85 @@
+package ru.ssau.tk.pmi.functions.functions;
+
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.BSplineFunction;
+
+import static org.junit.jupiter.api.Assertions.*;
+
+public class BSplineFunctionTest {
+    @Test
+    public void testSpline1() {
+        double[] nodes = {0.0, 0.0, 1.0, 2.0, 2.0};
+        double[] weights = {1.0, 2.0, 3.0};
+        BSplineFunction spline = new BSplineFunction(nodes, 1, weights);
+
+        assertEquals(1.0, spline.apply(0.0), 1e-9);
+        assertEquals(2.0, spline.apply(1.0), 1e-9);
+        assertEquals(0.0, spline.apply(2.0), 1e-9);
+    }
+
+    @Test
+    public void testSpline2() {
+        double[] nodes = {0.0, 0.0, 0.0, 1.0, 2.0, 3.0, 3.0, 3.0};
+        double[] weights = {1.0, 2.0, 3.0, 4.0, 5.0};
+        BSplineFunction spline = new BSplineFunction(nodes, 2, weights);
+
+        assertTrue(spline.apply(1.5) > 0.0);
+        assertEquals(0.0, spline.apply(-1.0), 1e-9);
+        assertEquals(0.0, spline.apply(3.5), 1e-9);
+    }
+
+    @Test
+    public void testSpline0() {
+        double[] nodes = {0.0, 1.0, 2.0, 3.0};
+        double[] weights = {1.0, 2.0, 3.0};
+        BSplineFunction spline = new BSplineFunction(nodes, 0, weights);
+
+        assertEquals(1.0, spline.apply(0.5), 1e-9);
+        assertEquals(2.0, spline.apply(1.5), 1e-9);
+        assertEquals(3.0, spline.apply(2.5), 1e-9);
+        assertEquals(0.0, spline.apply(3.5), 1e-9);
+    }
+
+    @Test
+    public void testUniformSplineCreation() {
+        double[] weights = {1.0, 2.0, 3.0, 4.0};
+        BSplineFunction spline = BSplineFunction.buildUniformSpline(0.0, 10.0, 2, 4, weights);
+
+        assertNotNull(spline);
+        assertEquals(2, spline.getSplineOrder());
+        assertEquals(4, spline.getWeights().length);
+
+        double result = spline.apply(5.0);
+        assertTrue(result >= 0.0);
+    }
+
+
+    @Test
+    public void testUniformSplineInvalidArguments() {
+        double[] weights = {1.0, 2.0, 3.0};
+
+        assertThrows(IllegalArgumentException.class,
+                () -> BSplineFunction.buildUniformSpline(0.0, 10.0, 3, 3, weights));
+    }
+
+
+    @Test
+    public void testEdgeCases() {
+        double[] nodes = {0.0, 0.0, 1.0, 1.0};
+        double[] weights = {1.0, 2.0};
+        BSplineFunction spline = new BSplineFunction(nodes, 1, weights);
+
+        assertEquals(1.0, spline.apply(0.0), 1e-9);
+        assertEquals(0.0, spline.apply(1.0), 1e-9);
+    }
+
+    @Test
+    public void testSingleSegment() {
+        double[] nodes = {0.0, 0.0, 1.0};
+        double[] weights = {5.0};
+        BSplineFunction spline = new BSplineFunction(nodes, 1, weights);
+
+        assertEquals(0.0, spline.apply(0.5), 1e-9);
+    }
+
+}
\ No newline at end of file
Index: src/test/java/ru/ssau/tk/pmi/functions/functions/ArrayTabulatedFunctionTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/test/java/ru/ssau/tk/pmi/functions/functions/ArrayTabulatedFunctionTest.java b/src/test/java/ru/ssau/tk/pmi/functions/functions/ArrayTabulatedFunctionTest.java
new file mode 100644
--- /dev/null	(date 1759256254112)
+++ b/src/test/java/ru/ssau/tk/pmi/functions/functions/ArrayTabulatedFunctionTest.java	(date 1759256254112)
@@ -0,0 +1,211 @@
+package ru.ssau.tk.pmi.functions.functions;
+import org.junit.jupiter.api.Test;
+import ru.ssau.tk.pmi.functions.ArrayTabulatedFunction;
+import ru.ssau.tk.pmi.functions.MathFunction;
+import ru.ssau.tk.pmi.functions.SqrFunction;
+
+import static org.junit.jupiter.api.Assertions.*;
+public class ArrayTabulatedFunctionTest {
+    @Test
+    public void testConstructorWithArrays() {
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(3, function.getCount());
+        assertEquals(1.0, function.leftBound(), 0.0001);
+        assertEquals(3.0, function.rightBound(), 0.0001);
+        assertEquals(1.0, function.getX(0), 0.0001);
+        assertEquals(2.0, function.getX(1), 0.0001);
+        assertEquals(3.0, function.getX(2), 0.0001);
+        assertEquals(10.0, function.getY(0), 0.0001);
+        assertEquals(20.0, function.getY(1), 0.0001);
+        assertEquals(30.0, function.getY(2), 0.0001);
+    }
+    @Test
+    public void testConstructorWithMathFunction() {
+        MathFunction source = new SqrFunction();
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(source, 0.0, 4.0, 5);
+        assertEquals(5, function.getCount());
+        assertEquals(0.0, function.leftBound(), 0.0001);
+        assertEquals(4.0, function.rightBound(), 0.0001);
+        assertEquals(0.0, function.getY(0), 0.0001);
+        assertEquals(4.0, function.getY(2), 0.0001);
+        assertEquals(16.0, function.getY(4), 0.0001);
+    }
+    @Test
+    public void testConstructorWithReversedBounds() {
+        MathFunction source = new SqrFunction();
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(source, 4.0, 0.0, 5);
+
+        assertEquals(5, function.getCount());
+        assertEquals(0.0, function.leftBound(), 0.0001);
+        assertEquals(4.0, function.rightBound(), 0.0001);
+    }
+    @Test
+    public void testConstructorWithEqualBounds() {
+        MathFunction source = new SqrFunction();
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(source, 3.0, 3.0, 4);
+        assertEquals(4, function.getCount());
+        assertEquals(3.0, function.leftBound(), 0.0001);
+        assertEquals(3.0, function.rightBound(), 0.0001);
+        assertEquals(9.0, function.getY(0), 0.0001);
+        assertEquals(9.0, function.getY(3), 0.0001);
+    }
+    @Test
+    public void testSetY() {
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        function.setY(1, 25.0);
+        assertEquals(25.0, function.getY(1), 0.0001);
+    }
+    @Test
+    public void testIndexOfX() {
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(0, function.indexOfX(1.0));
+        assertEquals(1, function.indexOfX(2.0));
+        assertEquals(2, function.indexOfX(3.0));
+        assertEquals(-1, function.indexOfX(4.0));
+    }
+    @Test
+    public void testIndexOfY() {
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(0, function.indexOfY(10.0));
+        assertEquals(1, function.indexOfY(20.0));
+        assertEquals(2, function.indexOfY(30.0));
+        assertEquals(-1, function.indexOfY(40.0));
+    }
+    @Test
+    public void testFloorIndexOfX() {
+        double[] xValues = {1.0, 2.0, 3.0, 4.0};
+        double[] yValues = {10.0, 20.0, 30.0, 40.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(0, function.floorIndexOfX(0.5));  // меньше первого - возвращает 0
+        assertEquals(0, function.floorIndexOfX(1.5));  // между 1.0 и 2.0
+        assertEquals(1, function.floorIndexOfX(2.5));  // между 2.0 и 3.0
+        assertEquals(2, function.floorIndexOfX(3.5));  // между 3.0 и 4.0
+        assertEquals(4, function.floorIndexOfX(4.0));  // равно последнему - возвращает последний интервал
+        assertEquals(4, function.floorIndexOfX(5.0));  // больше последнего - возвращает последний интервал
+    }
+    @Test
+    public void testApplyInterpolation() {
+        double[] xValues = {0.0, 2.0, 4.0};
+        double[] yValues = {0.0, 4.0, 16.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(2.0, function.apply(1.0), 0.0001);
+        assertEquals(10.0, function.apply(3.0), 0.0001);
+    }
+    @Test
+    public void testApplyExtrapolation() {
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {1.0, 4.0, 9.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        double leftResult = function.apply(0.0);
+        double rightResult = function.apply(4.0);
+        assertTrue(leftResult < 1.0);
+        assertTrue(rightResult > 9.0);
+    }
+    @Test
+    public void testApplySinglePoint() {
+        double[] xValues = {5.0};
+        double[] yValues = {25.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(25.0, function.apply(5.0), 0.0001);
+        assertEquals(25.0, function.apply(0.0), 0.0001);
+        assertEquals(25.0, function.apply(10.0), 0.0001);
+    }
+    @Test
+    public void testApplyExactMatch() {
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(xValues, yValues);
+        assertEquals(10.0, function.apply(1.0), 0.0001);
+        assertEquals(20.0, function.apply(2.0), 0.0001);
+        assertEquals(30.0, function.apply(3.0), 0.0001);
+    }
+
+    @Test
+    public void insertTestMiddle(){
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction func = new ArrayTabulatedFunction(xValues, yValues);
+
+        func.insert(2.5, 56);
+        assertEquals(2.5,func.getX(2));
+        assertEquals(3.0,func.getX(3));
+        assertEquals(56,func.getY(2));
+        assertEquals(20,func.getY(1));
+    }
+
+
+    @Test
+    public void insertTestEnd(){
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction func = new ArrayTabulatedFunction(xValues, yValues);
+
+        func.insert(6.8, 45);
+        assertEquals(6.8,func.getX(3));
+        assertEquals(3.0,func.getX(2));
+        assertEquals(45,func.getY(3));
+        assertEquals(20,func.getY(1));
+    }
+
+    @Test
+    public void insertTestBagging(){
+        double[] xValues = {1.0, 2.0, 3.0};
+        double[] yValues = {10.0, 20.0, 30.0};
+        ArrayTabulatedFunction func = new ArrayTabulatedFunction(xValues, yValues);
+
+        func.insert(0.8, 45);
+        assertEquals(0.8,func.getX(0));
+        assertEquals(2.0,func.getX(2));
+        assertEquals(45,func.getY(0));
+        assertEquals(10,func.getY(1));
+    }
+
+
+    @Test
+    public void testInsertMultipleValues() {
+
+        double[] xValues = {2.0, 4.0};
+        double[] yValues = {4.0, 8.0};
+        ArrayTabulatedFunction func = new ArrayTabulatedFunction(xValues, yValues);
+
+        func.insert(1.0, 2.0);
+        func.insert(3.0, 6.0);
+        func.insert(5.0, 10.0);
+
+        assertEquals(1.0,func.getX(0));
+        assertEquals(3.0,func.getX(2));
+        assertEquals(8,func.getY(3));
+        assertEquals(10,func.getY(4));
+    }
+    @Test
+    void testRemove_ValidIndex_RemovesElement() {
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(
+                new double[]{1.0, 2.0, 3.0, 4.0},
+                new double[]{10.0, 20.0, 30.0, 40.0}
+        );
+        function.remove(1);
+        assertEquals(3, function.getCount());
+        assertEquals(1.0, function.getX(0));
+        assertEquals(3.0, function.getX(1));
+        assertEquals(4.0, function.getX(2));
+    }
+    @Test
+    void testRemove_FirstElement_WorksCorrectly() {
+        ArrayTabulatedFunction function = new ArrayTabulatedFunction(
+                new double[]{1.0, 2.0, 3.0},
+                new double[]{10.0, 20.0, 30.0}
+        );
+        function.remove(0);
+        assertEquals(2, function.getCount());
+        assertEquals(2.0, function.getX(0));
+        assertEquals(3.0, function.getX(1));
+    }
+}
\ No newline at end of file
